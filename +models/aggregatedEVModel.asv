% Datei: +models/aggregatedEVModel.m
function [pEV_total, SoCvec, pEV_groups, SoC_groups] = aggregatedEVModel( ...
    resNoBatt_kW, dt, numEV, pMaxEV_kW, capacityEV_kWh, prevDayMean)
% aggregatedEVModel.m
% -------------------------------------------------------------------------
% Gruppenspezifisches EV-Modell für vier Fahrzeuggruppen (A–D)
%   – Notfall-Laden auf minSOC (40 %)
%   – PV-Überschuss-Laden bis maxSOC (90 %)
%   – Basalladen bis basalSOC (70 %), begrenzt durch prevDayMean
%   – V2G-Entladen bei hoher Netzlast, **nur so weit, dass
%     Residuallast ≤ prevDayMean bleibt (kein Überkompensieren)**
% -------------------------------------------------------------------------

%% Konstanten und Parameter
nSteps           = length(resNoBatt_kW);
pA=0.30; pB=0.25; pC=0.30; pD=0.15;                % Flottenanteile
minSOC  = 0.40;  basalSOC = 0.70;  maxSOC = 0.90;  % Grenzwerte

% Kapazitäten / Leistungen pro Gruppe
capA = capacityEV_kWh*pA; maxA = pMaxEV_kW*pA;
capB = capacityEV_kWh*pB; maxB = pMaxEV_kW*pB;
capC = capacityEV_kWh*pC; maxC = pMaxEV_kW*pC;
capD = capacityEV_kWh*pD; maxD = pMaxEV_kW*pD;

% Fahrverbrauch [kW]
dailyCons    = (2250/365)*numEV;
rateA = pA*dailyCons/(15-6);
rateB = pB*dailyCons/(24-(17-8));
rateC = pC*dailyCons/(18-9);
rateD = pD*dailyCons/6;

%% Speicher- und Leistungs-Vektoren
pEV_A = zeros(nSteps,1); pEV_B = pEV_A; pEV_C = pEV_A; pEV_D = pEV_A;
SoC_A = 0.5; SoC_B = 0.5; SoC_C = 0.5; SoC_D = 0.5;
SoC_A_vec = zeros(nSteps,1); SoC_B_vec = SoC_A_vec;
SoC_C_vec = SoC_A_vec;      SoC_D_vec = SoC_A_vec;

%% Hauptschleife
for i = 1:nSteps
    deltaP    = resNoBatt_kW(i);              % aktuelle Residuallast
    t_current = mod((i-1)*dt,24);             % Tageszeit [h]

    % Verfügbarkeits­masken
    availA =  t_current<6  || t_current>=15;
    availB =  t_current>=8 && t_current<17;
    availC =  t_current<9  || t_current>=18;
    availD = ~((t_current>=7 && t_current<10) || (t_current>=15 && t_current<18));

    %% 0) Fahrverbrauch abziehen
    driveA = (t_current>=6 && t_current<15);
    driveB = (t_current<8  || t_current>=17);
    driveC = (t_current>=9 && t_current<18);
    driveD = ((t_current>=7 && t_current<10) || (t_current>=15 && t_current<18));

    SoC_A = max(SoC_A - driveA*rateA*dt/capA, 0);
    SoC_B = max(SoC_B - driveB*rateB*dt/capB, 0);
    SoC_C = max(SoC_C - driveC*rateC*dt/capC, 0);
    SoC_D = max(SoC_D - driveD*rateD*dt/capD, 0);

    %% 1) Notfall-Laden auf minSOC (Gruppenweise)
    groups = {'A',availA,SoC_A,capA,maxA; ...
              'B',availB,SoC_B,capB,maxB; ...
              'C',availC,SoC_C,capC,maxC; ...
              'D',availD,SoC_D,capD,maxD};

    for g = 1:4
        if groups{g,2} && groups{g,3} < minSOC
            Eneed = (minSOC - groups{g,3}) * groups{g,4};
            Echg  = min(groups{g,5} * dt, Eneed);
            eval(sprintf('pEV_%s(i) = pEV_%s(i) - Echg/dt;',groups{g,1},groups{g,1}));
            groups{g,3} = groups{g,3} + Echg / groups{g,4};
        end
    end
    SoC_A = groups{1,3}; SoC_B = groups{2,3};
    SoC_C = groups{3,3}; SoC_D = groups{4,3};

    %% 2) PV-Überschuss-Laden (netzneutral)
    if deltaP < 0
        excess = -deltaP;
        w = [pA*availA, pB*availB, pC*availC, pD*availD];
        if sum(w) > 0
            share = w / sum(w) * excess;
            [pEV_A(i),SoC_A] = chargeGroup(availA,SoC_A,capA,maxA,share(1),maxSOC,dt,pEV_A(i));
            [pEV_B(i),SoC_B] = chargeGroup(availB,SoC_B,capB,maxB,share(2),maxSOC,dt,pEV_B(i));
            [pEV_C(i),SoC_C] = chargeGroup(availC,SoC_C,capC,maxC,share(3),maxSOC,dt,pEV_C(i));
            [pEV_D(i),SoC_D] = chargeGroup(availD,SoC_D,capD,maxD,share(4),maxSOC,dt,pEV_D(i));
        end

    %% 3) Basalladen (≤ prevDayMean)
    elseif deltaP >= 0 && deltaP < prevDayMean
        head = prevDayMean - deltaP;      % noch zulässige Netzlast
        % Reihenfolge egal (gleiche Prio)
        [pEV_A(i),SoC_A,head] = basalCharge(availA,SoC_A,capA,maxA,basalSOC,dt,head,pEV_A(i));
        [pEV_B(i),SoC_B,head] = basalCharge(availB,SoC_B,capB,maxB,basalSOC,dt,head,pEV_B(i));
        [pEV_C(i),SoC_C,head] = basalCharge(availC,SoC_C,capC,maxC,basalSOC,dt,head,pEV_C(i));
        [pEV_D(i),SoC_D,head] = basalCharge(availD,SoC_D,capD,maxD,basalSOC,dt,head,pEV_D(i));

    %% 4) V2G-Entladen – **nur Rest‐Defizit decken**
    elseif deltaP >= prevDayMean
        deficit = deltaP - prevDayMean;   % so viel muss max. kompensiert werden
        % Entladen in fester Reihenfolge (A→D)
        [pEV_A(i),SoC_A,deficit] = v2gDischarge(availA,SoC_A,capA,maxA,dt,deficit,pEV_A(i));
        [pEV_B(i),SoC_B,deficit] = v2gDischarge(availB,SoC_B,capB,maxB,dt,deficit,pEV_B(i));
        [pEV_C(i),SoC_C,deficit] = v2gDischarge(availC,SoC_C,capC,maxC,dt,deficit,pEV_C(i));
        [pEV_D(i),SoC_D,deficit] = v2gDischarge(availD,SoC_D,capD,maxD,dt,deficit,pEV_D(i));
    end

    %% SoC-Verläufe speichern
    SoC_A_vec(i)=SoC_A; SoC_B_vec(i)=SoC_B;
    SoC_C_vec(i)=SoC_C; SoC_D_vec(i)=SoC_D;
end

%% Ausgabe-Aggregation
pEV_total     = pEV_A + pEV_B + pEV_C + pEV_D;
SoCvec        = pA*SoC_A_vec + pB*SoC_B_vec + pC*SoC_C_vec + pD*SoC_D_vec;
pEV_groups.A  = pEV_A; pEV_groups.B  = pEV_B;
pEV_groups.C  = pEV_C; pEV_groups.D  = pEV_D;
SoC_groups.A  = SoC_A_vec; SoC_groups.B  = SoC_B_vec;
SoC_groups.C  = SoC_C_vec; SoC_groups.D  = SoC_D_vec;
end
%% ------------------------------------------------------------------------
function [pEV_i,SoC_i] = chargeGroup(avail,SoC_i,cap_i,max_i,Pshare,maxSOC,dt,pEV_i)
% Hilfsroutine: netzneutrales Laden
if avail && SoC_i < maxSOC
    P = min(max_i, Pshare);
    Etgt = (maxSOC - SoC_i) * cap_i;
    Echg = min(P*dt, Etgt);
    pEV_i = pEV_i - Echg/dt;
    SoC_i = SoC_i + Echg/cap_i;
end
end
% -------------------------------------------------------------------------
function [pEV_i,SoC_i,head] = basalCharge(avail,SoC_i,cap_i,max_i,targetSOC,dt,head,pEV_i)
% Hilfsroutine: Basalladen, begrenzt durch Netz‐Headroom
if avail && SoC_i < targetSOC && head > 0
    P = min([max_i, head]);
    Etgt = (targetSOC - SoC_i) * cap_i;
    Echg = min(P*dt, Etgt);
    pEV_i = pEV_i - Echg/dt;
    SoC_i = SoC_i + Echg/cap_i;
    head  = head - Echg/dt;              % Headroom verringern
end
end
% -------------------------------------------------------------------------
function [pEV_i,SoC_i,deficit] = v2gDischarge(avail,SoC_i,cap_i,max_i,dt,deficit,pEV_i)
% Hilfsroutine: V2G-Entladen, nur bis deficit abgearbeitet ist
if avail && SoC_i > 0.40 && deficit > 0
    P = min([max_i, deficit]);
    Eavail = (SoC_i - 0.40) * cap_i;
    Edisp  = min(P*dt, Eavail);
    pEV_i  = pEV_i + Edisp/dt;
    SoC_i  = SoC_i - Edisp/cap_i;
    deficit = deficit - Edisp/dt;         % Restdefizit aktualisieren
end
end
